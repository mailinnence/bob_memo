#include <pcap.h>
#include <stdbool.h>
#include <stdio.h>

void usage() {
	printf("syntax: pcap-test <interface>\n");  // <interface>는 사용자가 지정해야 할 네트워크 인터페이스를 나타내며
	printf("sample: pcap-test wlan0\n");        // 그 예시르 보여준다
}

typedef struct {
	char* dev_;
} Param;

Param param = {
	.dev_ = NULL
};
// .Param 을 가지고 와서 .dev_ = NULL 로 초기화



bool parse(Param* param, int argc, char* argv[]) {
	if (argc != 2) {              // if (argc != 2) {: 만약 실행 인수의 개수(argc)가 2가 아니면 실행합니다.
		usage();              // 사용법
		return false;
	}
	param->dev_ = argv[1];        // 사용자에게 받아온 인수를 대입시킨다.
	return true;
}

/* -----------------------------------------------------------------------------
디테일한 해석
argv[1]은 사용자가 입력한 첫 번째 인수를 나타냅니다. 
C 언어의 배열 인덱스는 0부터 시작하므로, 
argv[0]은 프로그램의 이름(실행 파일 이름)을 가리키고, argv[1]은 첫 번째 인수를 가리킵니다.

따라서, 예를 들어 sudo ./pcap-test와 같이 실행한 경우 argc는 1이 되며, argc != 2 조건이 참이 되어 인수가 부족하다는 경고 메시지를 출력하게 됩니다. 
그리고 sudo ./pcap-test ens33와 같이 실행한 경우 argc는 2이며, argv[1]은 "ens33"라는 문자열을 가리키게 됩니다. 이는 사용자가 입력한 네트워크 인터페이스를 나타내게 됩니다.

정리하자면 프로그램의 이름 + 인터페이스 = 2 이기 떄문에 받아온 인자의 갯수가 2가 아니라면  if (argc != 2) {  .... 
실행하지말고 사용법을 보여주는 usage 함수를 실행하라는 것 입니다.
*/ -----------------------------------------------------------------------------




int main(int argc, char* argv[]) {
	if (!parse(&param, argc, argv))		// 인자 확인 함수 실행
		return -1;

	char errbuf[PCAP_ERRBUF_SIZE];		// libpcap의 헤더 파일(<pcap.h>)에서 가져온 define 된 변수로 PCAP_ERRBUF_SIZE는 256으로 정의됩니다.
						// errbuf 배열은 256바이트 크기로 선언되어 오류 메시지를 저장하는 역할을 합니다



	pcap_t* pcap = pcap_open_live(param.dev_, BUFSIZ, 1, 1000, errbuf);
	// pcap_t는 libpcap에서 정의된 네트워크 패킷 캡처 세션 핸들을 나타내는 자료형
	// pcap_open_live() 함수는 libpcap 라이브러리에서 제공되는 함수로, 네트워크 인터페이스에서 실시간으로 패킷을 캡처하기 위한 세션을 엽니다
	// 성공적으로 패킷 캡처 세션을 열면 해당 세션에 대한 핸들을 반환하며, 
	// 이를 pcap_t* 타입의 포인터인 pcap 변수에 저장합니다. 이 핸들은 이후 패킷 캡처 세션을 조작하거나 패킷을 가져오기 위해 사용됩니다.


/* -----------------------------------------------------------------------------
param.dev_: 캡처할 네트워크 인터페이스의 이름을 나타내는 문자열입니다. 이는 사용자로부터 입력받은 인터페이스 이름입니다.
BUFSIZ: 패킷 캡처를 위한 버퍼의 크기입니다. BUFSIZ는 libpcap에서 미리 정의된 상수로, 보통 8192바이트로 설정됩니다. 
        이 버퍼는 캡처한 패킷 데이터를 임시로 저장하는 용도로 사용됩니다.
1: 캡처된 패킷을 즉시 처리하기 위한 옵션입니다. 1로 설정하면 패킷이 도착할 때마다 처리가 진행됩니다.
1000: 패킷을 캡처하기 위한 타임아웃 값입니다. 이 값은 밀리초 단위로 설정됩니다. 1000으로 설정하면 1초마다 타임아웃이 발생하여 패킷 캡처 작업이 수행됩니다.
errbuf: 오류 메시지를 저장하기 위한 버퍼입니다. 함수가 실패한 경우 오류 메시지가 errbuf에 저장됩니다.


*/ -----------------------------------------------------------------------------

	
	if (pcap == NULL) {
		fprintf(stderr, "pcap_open_live(%s) return null - %s\n", param.dev_, errbuf);
		return -1;
	}


	// pcap_open_live() 함수가 실패한 경우를 처리하는 부분
	// pcap_open_live() 함수는 네트워크 인터페이스에서 패킷 캡처 세션을 열고, 세션 핸들인 pcap_t를 반환합니다. 
	// 그러나 pcap_open_live() 함수가 실패하면 NULL을 반환하게 됩니다.
	
	while (true) {
		struct pcap_pkthdr* header;
		// struct pcap_pkthdr 구조체는 주로 libpcap 라이브러리에서 정의되어 있습니다. 
		// 이 라이브러리는 네트워크 패킷 캡처를 위한 기능을 제공하고, 네트워크 트래픽 분석과 패킷 처리를 위해 사용됩니다.
		
/* -----------------------------------------------------------------------------
struct pcap_pkthdr {
	struct timeval ts;  // 캡처된 패킷의 타임스탬프 (시간 정보)
	bpf_u_int32 caplen; // 캡처된 패킷의 길이 (caplen <= len)
	bpf_u_int32 len;    // 실제 패킷의 길이 (len은 패킷의 전체 길이)
	};		
*/ -----------------------------------------------------------------------------
		
		const u_char* packet;
		// u_char는 C 언어에서 사용되는 데이터 타입 중 하나로, "unsigned char"를 나타내는 줄임말입니다. 
		// 이는 부호 없는 8비트 정수를 나타내는 자료형으로, 값의 범위는 0부터 255까지입니다.

		// u_char 타입은 주로 바이트 단위의 데이터를 다루는 경우에 사용됩니다. 네트워크 패킷 처리, 이미지 처리, 이진 데이터 등의 다양한 상황에서 자주 활용됩니다. 
		// libpcap 라이브러리에서도 네트워크 패킷을 다루는데 사용되는 데이터의 타입으로 u_char가 자주 사용됩니다
		
		// char 쓰면 안되는 이유

/* -----------------------------------------------------------------------------
1.데이터 손실:
네트워크 패킷은 0부터 255까지의 값으로 이루어지는 이진 데이터입니다. 
패킷에 포함된 바이너리 데이터를 char 타입으로 처리하면, char 타입은 -128부터 127까지의 범위를 
가지므로 128부터 255 사이의 값은 정수로 표현될 때 음수로 간주됩니다. 
이로 인해 데이터 손실이 발생할 수 있습니다.

2.비교와 검사:
패킷 데이터의 일부 필드를 비교하거나 특정 값과 검사해야 할 때, u_char (부호 없는 정수)로 처리하는 것이 더 간편합니다. 
비트 비교 및 AND/OR 비트 연산과 같은 비트 수준의 작업에 u_char 타입을 사용하면 오류 없이 수행할 수 있습니다.
		
3.일관성:
패킷 처리 시에는 일반적으로 u_char 타입을 사용하는 것이 
네트워크에서 주고 받는 데이터 형식과 일관성을 유지하는 데 도움이 됩니다. 
네트워크 데이터는 주로 부호 없는 정수 형태로 인코딩되고 전송되는 경우가 많으므로, 
이와 일치하는 데이터 타입을 사용하면 더 적합하고 이해하기 쉬운 코드를 작성할 수 있습니다.
*/ -----------------------------------------------------------------------------
		
		int res = pcap_next_ex(pcap, &header, &packet);
/*

pcap_next_ex 함수는 libpcap 라이브러리의 주요 함수 중 하나로, 다음 패킷을 캡처하는 역할을 합니다.
이 함수는 네트워크 인터페이스로부터 다음 패킷을 읽어와서 메모리에 저장하고, 
해당 패킷에 대한 정보를 header와 packet 포인터를 통해 제공합니다.
함수의 반환값은 캡처한 패킷의 성공 여부를 나타내며, 상세한 정보는 res 변수에 저장됩니다.


int pcap_next_ex(
    pcap_t *p,            	      // pcap 핸들
    struct pcap_pkthdr **pkt_header,  // 캡처한 패킷의 헤더 정보를 저장하기 위한 포인터 변수
    const u_char **pkt_data	      // 캡처한 패킷의 데이터를 저장하기 위한 포인터 변수
);


>>

int res = pcap_next_ex(
			pcap, 		// 실시간으로 패킷을 캡처하기 위한 세션
   			&header, 	// 캡처한 패킷의 헤더 정보
							struct pcap_pkthdr {
								struct timeval ts;  // 캡처된 패킷의 타임스탬프 (시간 정보)
								bpf_u_int32 caplen; // 캡처된 패킷의 길이 (caplen <= len)
								bpf_u_int32 len;    // 실제 패킷의 길이 (len은 패킷의 전체 길이)
								};		
      			&packet		// 캡처한 패킷의 데이터를 저장하기 위한 포인터 변수
	 );
*/


		
		if (res == 0) continue;					// res가 0인 경우는 패킷을 캡처하지 못한 경우입니다. 
									// 즉, 새로운 패킷이 도착하지 않은 상태입니다.
		if (res == PCAP_ERROR || res == PCAP_ERROR_BREAK) {	// 오류가 발생한 경우 
			printf("pcap_next_ex return %d(%s)\n", res, pcap_geterr(pcap));
			// pcap_geterr(pcap) 함수를 사용하여 pcap 핸들에 저장된 오류 메시지를 가져옵니다.
			// 오류가 발생한 경우: res 값은 PCAP_ERROR 또는 PCAP_ERROR_BREAK와 같은 오류 코드입니다. 
			// 이 경우 pcap_geterr(pcap) 함수를 사용하여 pcap 핸들에 저장된 오류 메시지를 가져오고, 
			// 오류 내용과 함께 오류 메시지를 출력
			// %d와 %s는 printf 함수에서 사용하는 형식 지정자로, 순서대로 res와 pcap_geterr(pcap)의 값을 출력합니다.
			break;
		}
		printf("%u bytes captured\n", header->caplen);


/* -----------------------------------------------------------------------------
struct pcap_pkthdr {
	struct timeval ts;  // 캡처된 패킷의 타임스탬프 (시간 정보)
	bpf_u_int32 caplen; // 캡처된 패킷의 길이 (caplen <= len)
	bpf_u_int32 len;    // 실제 패킷의 길이 (len은 패킷의 전체 길이)
	};		
*/ -----------------------------------------------------------------------------

	}

	pcap_close(pcap);
		// pcap_t 핸들을 닫는 역할을 합니다.
		// 네트워크 디바이스를 더 이상 사용하지 않을 때 핸들을 닫아 리소스를 반환합니다.
}

